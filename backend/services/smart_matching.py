"""
WaterXchange — Smart Matching Algorithm
=========================================

Multi-objective optimization matching engine that balances:
  1. ECONOMIC BENEFIT  — Maximize gains from trade (consumer + producer surplus)
  2. ENVIRONMENTAL RISK — Minimize subsidence, GW depletion, water quality degradation

Theory:
  Match Score = α × Economic Score  −  β × Environmental Risk Score

  Where:
    Economic Score = normalized total surplus per AF
    Environmental Risk = weighted sum of 5 risk factors (each 0–1)
    α, β = tunable weights (default α=0.6, β=0.4)

Economic Model Reference:
  - Marginal Revenue Product of Water (MRP_w): the revenue generated by the
    last acre-foot of water applied to a crop.  A farmer growing pistachios
    ($867/AF MRP) should BUY from a farmer growing alfalfa ($60/AF MRP).
    Gains from trade = $867 − $60 = $807/AF of pure economic surplus.
  - PPIC "California's Water Market, By the Numbers" (Hanak & Stryjewski, 2012)
  - UC Davis Cost & Return Studies (2023-2024)

Environmental Model Reference:
  - Kern County GSP Table 13-3 (p.681): subsidence rates, GW decline by HCM area
  - SGMA §10727.2: six sustainability indicators as constraints
  - Pigou externality pricing: social cost of subsidence per AF extracted
"""

from typing import List, Dict, Any, Tuple, Optional
import math


# ═══════════════════════════════════════════════════════════════
#  HCM AREA RISK BASELINES (from GSP Table 13-3, p.681)
# ═══════════════════════════════════════════════════════════════

HCM_RISK = {
    "Kern River Fan":     {"subsidence": 0.022, "gw_decline": 3.7, "sub_mt": 0.27},
    "North Basin":        {"subsidence": 0.059, "gw_decline": 5.2, "sub_mt": 0.85},
    "South Basin":        {"subsidence": 0.037, "gw_decline": 4.9, "sub_mt": 0.48},
    "East Margin":        {"subsidence": 0.006, "gw_decline": 6.5, "sub_mt": 0.14},
    "Western Fold Belt":  {"subsidence": 0.008, "gw_decline": 4.1, "sub_mt": 0.10},
}

# Maximum observed values for normalization
MAX_SUBSIDENCE = 0.059      # North Basin
MAX_GW_DECLINE = 6.5        # East Margin
MAX_NITRATE    = 15.0       # mg/L — well above MCL of 10
MAX_DOMESTIC_WELLS = 10


# ═══════════════════════════════════════════════════════════════
#  ECONOMIC SCORING
# ═══════════════════════════════════════════════════════════════

def compute_economic_score(seller: Dict, buyer: Dict) -> Dict[str, Any]:
    """
    Compute the economic benefit of a trade between seller and buyer.

    Returns:
      - trade_price: midpoint between ask and bid
      - consumer_surplus_per_af: buyer's gain per AF (MRP - trade_price)
      - producer_surplus_per_af: seller's gain per AF (trade_price - opp_cost)
      - total_surplus_per_af: total social gain
      - trade_quantity: minimum of what seller offers and buyer wants
      - total_surplus: total_surplus_per_af × trade_quantity
      - normalized_score: 0-1 scale
    """
    ask = seller['ask_price']
    bid = buyer['bid_price']

    # Price must overlap
    if bid < ask:
        return {
            "feasible": False,
            "reason": f"No price overlap: bid ${bid} < ask ${ask}",
            "normalized_score": 0.0,
        }

    # Execution at midpoint (standard double auction)
    trade_price = (ask + bid) / 2.0

    # Surplus computation
    buyer_mrp = buyer.get('marginal_value_of_next_af', bid)
    seller_opp_cost = seller.get('marginal_value_of_last_af', ask)

    consumer_surplus = buyer_mrp - trade_price
    producer_surplus = trade_price - seller_opp_cost
    total_surplus_per_af = consumer_surplus + producer_surplus  # = buyer_mrp - seller_opp_cost

    # Quantity
    sell_qty = seller.get('selling_af', 0)
    buy_qty  = buyer.get('buying_af', 0)
    trade_qty = min(sell_qty, buy_qty)

    total_surplus = total_surplus_per_af * trade_qty

    # Normalize to 0-1 (theoretical max surplus ≈ $1300/AF for mandarin vs alfalfa)
    max_possible_surplus = 1400.0
    normalized = min(1.0, max(0.0, total_surplus_per_af / max_possible_surplus))

    return {
        "feasible": True,
        "trade_price": round(trade_price, 2),
        "trade_quantity_af": trade_qty,
        "buyer_mrp": buyer_mrp,
        "seller_opp_cost": seller_opp_cost,
        "consumer_surplus_per_af": round(consumer_surplus, 2),
        "producer_surplus_per_af": round(producer_surplus, 2),
        "total_surplus_per_af": round(total_surplus_per_af, 2),
        "total_surplus_usd": round(total_surplus, 2),
        "total_trade_value_usd": round(trade_price * trade_qty, 2),
        "normalized_score": round(normalized, 4),
    }


# ═══════════════════════════════════════════════════════════════
#  ENVIRONMENTAL RISK SCORING
# ═══════════════════════════════════════════════════════════════

def compute_environmental_risk(seller: Dict, buyer: Dict) -> Dict[str, Any]:
    """
    Compute the environmental risk of a trade.
    Risk is assessed at the BUYER's location (where additional extraction occurs).

    Five risk factors (each 0–1, higher = worse):
      1. Subsidence Risk        — buyer HCM area subsidence rate vs max
      2. GW Depletion Risk      — buyer HCM area GW decline rate vs max
      3. Water Quality Risk     — buyer nitrate level vs MCL
      4. Domestic Well Risk     — number of domestic wells near buyer
      5. Inter-GSA Complexity   — different GSAs add coordination cost

    Each factor is weighted:
      subsidence: 0.30, gw_depletion: 0.25, water_quality: 0.20,
      domestic_wells: 0.15, inter_gsa: 0.10
    """
    buyer_hcm = buyer.get('hcm_area', 'Kern River Fan')
    hcm_data  = HCM_RISK.get(buyer_hcm, HCM_RISK['Kern River Fan'])

    # Factor 1: Subsidence
    subsidence_raw = hcm_data['subsidence'] / MAX_SUBSIDENCE
    subsidence_risk = min(1.0, subsidence_raw)

    # Factor 2: GW Depletion
    gw_decline_raw = hcm_data['gw_decline'] / MAX_GW_DECLINE
    gw_depletion_risk = min(1.0, gw_decline_raw)

    # Factor 3: Water Quality (nitrate vs MCL of 10 mg/L)
    nitrate = buyer.get('nitrate_mg_l', 5.0)
    if nitrate >= 10.0:
        wq_risk = min(1.0, nitrate / MAX_NITRATE)
    else:
        wq_risk = nitrate / 20.0  # low risk if below MCL

    # Factor 4: Domestic Well Interference
    dom_wells = buyer.get('domestic_wells_1mi', 0)
    domestic_risk = min(1.0, dom_wells / MAX_DOMESTIC_WELLS)

    # Factor 5: Inter-GSA Complexity
    same_gsa = seller.get('gsa', '') == buyer.get('gsa', '')
    inter_gsa_risk = 0.0 if same_gsa else 0.3

    # Weighted combination
    weights = {
        'subsidence':     0.30,
        'gw_depletion':   0.25,
        'water_quality':  0.20,
        'domestic_wells': 0.15,
        'inter_gsa':      0.10,
    }

    composite = (
        weights['subsidence']     * subsidence_risk +
        weights['gw_depletion']   * gw_depletion_risk +
        weights['water_quality']  * wq_risk +
        weights['domestic_wells'] * domestic_risk +
        weights['inter_gsa']      * inter_gsa_risk
    )

    return {
        "buyer_hcm_area": buyer_hcm,
        "subsidence_risk":   round(subsidence_risk, 4),
        "gw_depletion_risk": round(gw_depletion_risk, 4),
        "water_quality_risk": round(wq_risk, 4),
        "domestic_well_risk": round(domestic_risk, 4),
        "inter_gsa_risk":     round(inter_gsa_risk, 4),
        "composite_risk":     round(composite, 4),
        "risk_details": {
            "subsidence_rate": hcm_data['subsidence'],
            "gw_decline_ft_yr": hcm_data['gw_decline'],
            "buyer_nitrate": nitrate,
            "domestic_wells": dom_wells,
            "same_gsa": same_gsa,
        }
    }


# ═══════════════════════════════════════════════════════════════
#  COMPOSITE MATCH SCORING
# ═══════════════════════════════════════════════════════════════

def compute_match_score(
    seller: Dict,
    buyer: Dict,
    alpha: float = 0.6,
    beta: float = 0.4
) -> Dict[str, Any]:
    """
    Composite match score = α × economic_score − β × environmental_risk

    Higher is better. Range roughly [-0.4, +0.6].
    """
    econ = compute_economic_score(seller, buyer)
    env  = compute_environmental_risk(seller, buyer)

    if not econ['feasible']:
        return {
            "feasible": False,
            "reason": econ.get('reason', 'No price overlap'),
            "match_score": -1.0,
            "economic": econ,
            "environmental": env,
        }

    match_score = alpha * econ['normalized_score'] - beta * env['composite_risk']

    return {
        "feasible": True,
        "seller_id": seller['id'],
        "buyer_id": buyer['id'],
        "seller_name": seller['name'],
        "buyer_name": buyer['name'],
        "match_score": round(match_score, 4),
        "trade_price": econ['trade_price'],
        "trade_quantity_af": econ['trade_quantity_af'],
        "total_surplus_per_af": econ['total_surplus_per_af'],
        "total_surplus_usd": econ['total_surplus_usd'],
        "total_trade_value_usd": econ['total_trade_value_usd'],
        "environmental_risk": env['composite_risk'],
        "economic": econ,
        "environmental": env,
    }


# ═══════════════════════════════════════════════════════════════
#  OPTIMAL MATCHING — GREEDY ASSIGNMENT
# ═══════════════════════════════════════════════════════════════

def run_matching(
    pool: List[Dict],
    alpha: float = 0.6,
    beta: float = 0.4
) -> Dict[str, Any]:
    """
    Greedy matching algorithm:
      1. Compute match scores for all feasible (seller, buyer) pairs
      2. Sort by match_score descending
      3. Greedily assign: each seller/buyer matched at most once
      4. Return matched trades + unmatched orders + full matrix

    Returns dict with:
      - 'matches': list of matched trades (ordered by score)
      - 'unmatched_sellers': sellers not matched
      - 'unmatched_buyers': buyers not matched
      - 'match_matrix': full NxM scoring matrix
      - 'total_economic_surplus': sum of all matched surplus
      - 'avg_environmental_risk': average risk of matched trades
    """
    sellers = [f for f in pool if f['role'] == 'SELLER']
    buyers  = [f for f in pool if f['role'] == 'BUYER']

    # Build full matrix
    matrix = []
    for s in sellers:
        for b in buyers:
            score = compute_match_score(s, b, alpha, beta)
            matrix.append(score)

    # Filter feasible, sort by match_score descending
    feasible = [m for m in matrix if m['feasible']]
    feasible.sort(key=lambda x: x['match_score'], reverse=True)

    # Greedy assignment — only match if composite score > 0
    # (negative scores mean environmental cost exceeds economic benefit)
    matched_sellers = set()
    matched_buyers  = set()
    matches = []
    rejected = []

    for m in feasible:
        sid = m['seller_id']
        bid = m['buyer_id']
        if sid not in matched_sellers and bid not in matched_buyers:
            if m['match_score'] > 0:
                matches.append(m)
                matched_sellers.add(sid)
                matched_buyers.add(bid)
            else:
                rejected.append(m)

    unmatched_sellers = [s for s in sellers if s['id'] not in matched_sellers]
    unmatched_buyers  = [b for b in buyers  if b['id'] not in matched_buyers]

    total_surplus = sum(m['total_surplus_usd'] for m in matches)
    avg_risk = (
        sum(m['environmental_risk'] for m in matches) / len(matches)
        if matches else 0
    )
    total_volume = sum(m['trade_quantity_af'] for m in matches)
    total_value  = sum(m['total_trade_value_usd'] for m in matches)

    return {
        'matches': matches,
        'rejected': rejected,
        'unmatched_sellers': unmatched_sellers,
        'unmatched_buyers': unmatched_buyers,
        'match_matrix': matrix,
        'total_economic_surplus': round(total_surplus, 2),
        'avg_environmental_risk': round(avg_risk, 4),
        'total_volume_af': total_volume,
        'total_trade_value_usd': round(total_value, 2),
        'num_trades': len(matches),
        'num_rejected': len(rejected),
        'alpha': alpha,
        'beta': beta,
    }


# ═══════════════════════════════════════════════════════════════
#  SENSITIVITY ANALYSIS — vary α and β
# ═══════════════════════════════════════════════════════════════

def run_sensitivity(pool: List[Dict]) -> List[Dict[str, Any]]:
    """
    Run matching at different (α, β) settings to show trade-off:
      - α=1.0, β=0.0  → Pure economic (maximize surplus, ignore environment)
      - α=0.6, β=0.4  → Balanced (WaterXchange default)
      - α=0.3, β=0.7  → Environmental priority (minimize risk)
    """
    scenarios = [
        {"name": "Pure Economic",      "alpha": 1.0, "beta": 0.0, "description": "Maximize surplus, ignore env risk"},
        {"name": "WaterXchange Default","alpha": 0.6, "beta": 0.4, "description": "Balance economic benefit + env safety"},
        {"name": "Environmental First", "alpha": 0.3, "beta": 0.7, "description": "Prioritize environmental protection"},
    ]

    results = []
    for s in scenarios:
        result = run_matching(pool, alpha=s['alpha'], beta=s['beta'])
        result['scenario_name'] = s['name']
        result['scenario_description'] = s['description']
        results.append(result)

    return results
